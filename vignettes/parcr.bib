@software{8bit-pixies2021,
  title = {8bit-Pixies/{{Ramble}}},
  author = {8bit-pixies},
  date = {2021-07-16T15:23:36Z},
  origdate = {2014-11-18T06:29:32Z},
  url = {https://github.com/8bit-pixies/Ramble},
  urldate = {2023-12-25},
  abstract = {A R parser based on combinatory parsers.},
  keywords = {combinatory-parsers,cran,parser-combinators,parsing,r}
}

@software{Fidler2023,
  title = {Dparser: {{Port}} of '{{Dparser}}' {{Package}}},
  shorttitle = {Dparser},
  author = {Fidler, Matthew and Plevyak, John},
  date = {2023-12-08},
  url = {https://cran.r-project.org/web/packages/dparser/},
  urldate = {2023-12-25},
  abstract = {A Scannerless GLR parser/parser generator. Note that GLR standing for "generalized LR", where L stands for "left-to-right" and R stands for "rightmost (derivation)". For more information see {$<$}https://en.wikipedia.org/wiki/GLR\_parser{$>$}. This parser is based on the Tomita (1987) algorithm. (Paper can be found at {$<$}https://aclanthology.org/P84-1073.pdf{$>$}). The original 'dparser' package documentation can be found at {$<$}https://dparser.sourceforge.net/{$>$}. This allows you to add mini-languages to R (like rxode2's ODE mini-language Wang, Hallow, and James 2015 {$<$}doi:10.1002/psp4.12052{$>$}) or to parse other languages like 'NONMEM' to automatically translate them to R code. To use this in your code, add a LinkingTo dparser in your DESCRIPTION file and instead of using \#include {$<$}dparse.h{$>$} use \#include {$<$}dparser.h{$>$}. This also provides a R-based port of the make\_dparser {$<$}https://dparser.sourceforge.net/d/make\_dparser.cat{$>$} command called mkdparser(). Additionally you can parse an arbitrary grammar within R using the dparse() function, which works on most OSes and is mainly for grammar testing. The fastest parsing, of course, occurs at the C level, and is suggested.},
  version = {1.3.1-11}
}

@article{Hutton1992,
  title = {Higher-Order Functions for Parsing},
  author = {Hutton, Graham},
  date = {1992-07},
  journaltitle = {Journal of Functional Programming},
  shortjournal = {J. Funct. Programming},
  volume = {2},
  number = {3},
  pages = {323--343},
  publisher = {{Cambridge University Press}},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796800000411},
  abstract = {Abstract                            In               combinator parsing               , the text of parsers resembles BNF notation. We present the basic method, and a number of extensions. We address the special problems presented by white-space, and parsers with separate lexical and syntactic phases. In particular, a combining form for handling the ‘offside rule’ is given. Other extensions to the basic method include an ‘into’ combining form with many useful applications, and a simple means by which combinator parsers can produce more informative error messages.},
  langid = {american},
  file = {/home/douwe/Zotero/storage/E8A2MR2B/Hutton - 1992 - Higher-order functions for parsing.pdf}
}

@software{Siu2016,
  title = {Ramble: {{Parser Combinator}} for {{R}}},
  shorttitle = {Ramble},
  author = {Siu, Chapman},
  date = {2016-10-29},
  url = {https://cran.r-project.org/web/packages/Ramble/index.html},
  urldate = {2023-12-25},
  abstract = {Parser generator for R using combinatory parsers. It is inspired by combinatory parsers developed in Haskell.},
  version = {0.1.1}
}

@inproceedings{Turner1985,
  title = {Miranda: {{A}} Non-Strict Functional Language with Polymorphic Types},
  shorttitle = {Miranda},
  booktitle = {Functional {{Programming Languages}} and {{Computer Architecture}}},
  author = {Turner, D. A.},
  editor = {Jouannaud, Jean-Pierre},
  editorb = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N.},
  editorbtype = {redactor},
  date = {1985},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {201},
  pages = {1--16},
  publisher = {{Springer}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-15975-4_26},
  url = {http://link.springer.com/10.1007/3-540-15975-4_26},
  isbn = {978-3-540-39677-2},
  langid = {american},
  keywords = {Abstract Data Type,Abstract Type,Data Type,Free Algebra,Functional Programming},
  file = {/home/douwe/Zotero/storage/8934QNWZ/Turner - 1985 - Miranda A non-strict functional language with pol.pdf}
}

@article{Turner1986,
  title = {An Overview of {{Miranda}}},
  author = {Turner, D},
  date = {1986-12},
  journaltitle = {ACM SIGPLAN Notices},
  shortjournal = {Acm Sigplan Notices},
  volume = {21},
  number = {12},
  pages = {158--166},
  issn = {0362-1340, 1558-1160},
  doi = {10.1145/15042.15053},
  url = {https://dl.acm.org/doi/10.1145/15042.15053},
  urldate = {2023-12-27},
  langid = {american},
  file = {/home/douwe/Zotero/storage/X6JLARYG/Turner - 1986 - An overview of Miranda.pdf}
}

@software{zotero-10025,
  title = {Closures},
  url = {https://cran.r-project.org/web/packages/Ramble/vignettes/Higher-Order_Functions_for_Parsing_in_R.html},
  urldate = {2023-12-25},
  abstract = {A parser is any program which analyses text to determine its logical structure. For example, the parser phase in a compiler takes a program text, and produces a parse tree which expounds the structure of the program. The form of this input is usually defined by a context-free grammar, using BNF notation. Prasers themselves may be built by hand, but are most often generated automatically using tools like Lex and Yacc from Unix (Aho86).}
}

@online{zotero-10028,
  title = {Miranda Homepage},
  url = {https://www.cs.kent.ac.uk/people/staff/dat/miranda/},
  urldate = {2023-12-27},
  langid = {american},
  file = {/home/douwe/Zotero/storage/M85EHXM9/miranda.html}
}
