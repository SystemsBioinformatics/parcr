---
title: "Creating parser combinators"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating parser combinators}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(parcr)
```

## Example: parsing fasta sequence files

As an example of a real application let's try to write a parser for fasta file.

A nucleotide fasta file could look like the example below 

```
>sequence1
TACGTTGTTTTT
CGG

>sequence2
TGGGTTAAATTT
CTTGGCTTTATT
CCGGA
```

Since fasta files are text files we could read such a file using `readLines()`.
Below we simulate the result of reading the file above by constructing a 
character vector called `file` that we will try to parse in this document.

```{r}
file <- c(
  ">sequence1", "TACGTTGTTTTT", "CGG",
  "",
  ">sequence2", "TGGGTTAAATTT", "CTTGGCTTTATT", "CCGGA"
)
```

A faste file consists of one or more sequence blocks, each with a header[^1] 
and a sequence, and each sequence consists of one or more lines of consecutive
symbols without spaces, representing the nucleotides. A sequence block could be
preceded by zero or more empty lines. This description already allows us to 
create a few elements of the `fasta` parser that we want to make:

[^1]: Note that fasta headers can be much more complicated than we pretend here.

```{r}
SequenceBlock <- function() {
  MaybeEmpty() %then% 
    Header() %then% 
    Sequence()
}

Sequence <- function() {
  one.or.more(SequenceLine())
}

Fastafile <- function() {
  one.or.more(SequenceBlock())
}
```

Now we need line-parsers `Header()` and `SequenceLine()` that recognize and 
process these elements in the character vector `file`. We use functions from
`stringr` to do this in a few helper functions.

```{r}
# returns TRUE/FALSE
is.header <- function(line) {
  stringr::str_detect(line, "^>[ \\t]?(\\w+)")
}

# returns the title after the ">"
parse.header <- function(line) {
  stringr::str_match(line, "^>[ \\t]?(\\w+)")
}

# returns TRUE/FALSE
is.sequence.line <- function(line) {
  stringr::str_detect(line, "[GATC]+")
}

# returns the nucleotide string
parse.sequence.line <- function(line) {
  stringr::str_match(line, "([GATC]+)")
}
```

Then we define the parsers.

```{r}
Header <- function() {
  satisfy(is.header) %using% 
    function(line) {
      matches <- parse.header(line)
      return(matches[2])
    }
}

SequenceLine <- function() {
  satisfy(is.sequence.line) %using% 
    function(line) {
      matches <- parse.sequence.line(line)
      return(matches[2])
    }
}
```

Now we use the output

```{r}
Fastafile() (file)
```

The problem with this output is that is not well-structured, and it is difficult
to extract the individual sequences and headers from it. We can structure this 
output by letting every sequence block be returned as an element of a list. We
extend the `SequenceBlock` parser by changing its output with a function using 
the `%using%` operator:

```{r}
SequenceBlock <- function() {
  MaybeEmpty() %then% 
    Header() %then% 
    Sequence() %using%
    function(x) list(x)
}
```

Now the result is a list of two lists, one for each sequence.

```{r}
Fastafile() (file)[["L"]]
```

In principle, this is which looks easier to extract information from, but we can
improve this. First, we want the sequences to appear as one long string, not as
separate character vectors. To attain this goal we extend the `Sequence` parser
by collapsing its output:

```{r}
Sequence <- function() {
  one.or.more(SequenceLine()) %using% 
    function(x) {
      paste(x, collapse="")
    }
}
```

Then we get

```{r}
Fastafile() (file)[["L"]]
```

We know that the first element in each of these lists elements is the header, 
and the second element is the complete sequence. Why not just attach a name 
to each element in these lists? This would make extracting the information even
easier:

```{r}
Header <- function() {
  satisfy(is.header) %using% 
    function(line) {
      matches <- parse.header(line)
      list(header = matches[2])
    }
}

Sequence <- function() {
  one.or.more(SequenceLine()) %using% 
    function(x) {
      list(sequence = paste(x, collapse=""))
    }
}
```

Finally, we have our desired output.

```{r}
d <- Fastafile() (file)[["L"]]
d
```

Let's present the result more concisely:

```{r}
invisible(lapply(d, function(x) {cat(x$header, x$sequence, "\n")}))
```
