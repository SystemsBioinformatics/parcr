% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/basic_parsers.R
\name{match.s}
\alias{match.s}
\title{The parser that identifies a string and produces custom output.}
\usage{
match.s(s)
}
\arguments{
\item{s}{A string-parsing function.}
}
\description{
\code{match.s} matches a string using a function and returns a desired object type.
}
\details{
The function \code{s} should take a character vector as its single argument. It
can return any object when succeeding, but to signal to the parser that it
has failed it must return \code{list()} as output when failing. When constructing
the output you should realize that the function will be given a single-
element character vector (a string). This often simplifies further
processing.

This parser short-cuts the pattern \code{satisfy(b) \%using\% f}. With \code{match.s}
you do not have to write separate predicate and processing functions \code{b} and
\code{f} when identification and parsing can be done with a single string
parsing function \code{s}.
}
\examples{
want_integers <- function(x) {
  m <- gregexpr("[[:digit:]]+", x)
  matches <- as.numeric(regmatches(x,m)[[1]])
  if (length(matches)==0) {
    return(list())
  } else {
    return(matches)
  }
}
match.s(want_integers) ("12 15 16 and some text") # success
match.s(want_integers) ("some text") # failure

}
