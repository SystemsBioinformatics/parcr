% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/basic_parsers.R
\name{\%then\%}
\alias{\%then\%}
\title{The parser of sequences of parsers.}
\usage{
p1 \%then\% p2
}
\arguments{
\item{p1, p2}{Two parsers}
}
\value{
A parser
}
\description{
\code{(p1 \%then\% p2)} recognizes anything that \code{p1} and \code{p2} would if placed in
succession.
}
\details{
For example, applying the parser \verb{(literal 'a' \%then\% literal 'b')} to the
input \code{'abcd'} gives the result \verb{[(('a','b'),'cd')]}. Then then combinator
is an excellent example of list comprehension notation, analogous to set
comprehension in mathematics (e.g.
\eqn{\{x^2 | x \in \mathbb{N} \land x \leq 10\}} defines the first ten
squares), except that lists replace sets, and elements are drawn in a
determined order. Much of the elegance of the then combinator would be lost
if this notation were not available.
}
\section{Definition}{


\if{html}{\out{<div class="sourceCode">}}\preformatted{(p1 \%then\% p2) (x) = [((v1,v2),out2) | (v1,outl) <- p1 inp;`
                                     (v2,out2) <- p2 out1]`
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{(p1 \%then\% p2) (x): fail()(x)             when x = NULL
                  : succeed(x[1]) (x[-1]) when b(x[1]])
             : fail()(x)             otherwise
}\if{html}{\out{</div>}}
}

\examples{
starts_with_a <- function(x) grepl("^a",x[1])
starts_with_b <- function(x) grepl("^b",x[1])
(satisfy(starts_with_a) \%then\% satisfy(starts_with_b)) (c("ab", "bc", "de")) # success
(satisfy(starts_with_a) \%then\% satisfy(starts_with_b)) (c("bb", "bc", "de")) # failure
(satisfy(starts_with_a) \%then\% satisfy(starts_with_b)) (c("ab", "ac", "de")) # failure
}
\seealso{
The element-discarding versions \link{\%xthen\%} and \link{\%thenx\%}
}
