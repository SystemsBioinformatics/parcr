% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parser.R
\name{\%then\%}
\alias{\%then\%}
\title{The parser of sequences of parsers.}
\usage{
p1 \%then\% p2
}
\arguments{
\item{p1, p2}{Two parsers}
}
\value{
A parser
}
\description{
\code{(p1 \%then\% p2)} recognizes anything that \code{p1} and \code{p2} would if placed in
succession.
}
\details{
For example, applying the parser \verb{(literal 'a' \%then\% literal 'b')} to the
input \code{'abcd'} gives the result \verb{[(('a','b'),'cd')]}. Then then combinator
is an excellent example of list comprehension notation, analogous to set
comprehension in mathematics (e.g.
\eqn{\{x^2 | x \in \mathbb{N} \land x \leq 10\}} defines the first ten
squares), except that lists replace sets, and elements are drawn in a
determined order. Much of the elegance of the then combinator would be lost
if this notation were not available.
}
\section{Definition}{


\verb{(p1 \%then\% p2) (x) = [((v1,v2),out2) | (v1,outl) <- p1 inp;}

\verb{                                       (v2,out2) <- p2 out1]}

[((v1,v2),out2) | (v1,outl) <- p1 inp;`

`                                       (v2,out2) <- p2 out1]: R:((v1,v2),out2)\%20\%7C\%20(v1,outl)\%20\%3C-\%20p1\%20inp;\%60\%0A\%0A\%60\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20(v2,out2)\%20\%3C-\%20p2\%20out1
}

\examples{
starts_with_a <- function(x) grepl("^a",x[1])
starts_with_b <- function(x) grepl("^b",x[1])
(satisfy(starts_with_a) \%then\% satisfy(starts_with_b)) (c("ab", "bc", "de")) # success
(satisfy(starts_with_a) \%then\% satisfy(starts_with_b)) (c("bb", "bc", "de")) # failure
(satisfy(starts_with_a) \%then\% satisfy(starts_with_b)) (c("ab", "ac", "de")) # failure
}
\seealso{
The element-discarding versions \link{\%xthen\%} and \link{\%thenx\%}
}
