% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parser.R
\name{zero.or.more}
\alias{zero.or.more}
\alias{one.or.more}
\alias{exactly}
\alias{zero.or.one}
\alias{match.n}
\title{Quantifying parsers for p}
\usage{
zero.or.more(p)

one.or.more(p)

exactly(n, p)

zero.or.one(p)

match.n(n, p)
}
\arguments{
\item{p}{A parser}

\item{n}{An integer}
}
\value{
A parser
}
\description{
Quantifying parsers for p
}
\section{Formal description}{


\verb{zero.or.more p = ((p \%then\% zero.or.more p) \%using\% cons) \%alt\% (succeed [])}

where \code{cons} is the list constructor: \code{cons (x,xs) = x:xs}

\verb{one.or.more p = (p \%then\% zero.or.more p) \%using\% cons.}

Note that these parsers correspond to the \code{many} (\code{zero.or.more}) and
\code{some} (\verb{one.or,more}) parsers described in Hutton. The names used here are
more clear about what we expect.
}

\examples{
zero.or.more(literal("A")) (c("A",LETTERS[1:5]))
zero.or.more(literal("A")) (LETTERS[2:5])
one.or.more(literal("A")) (c("A",LETTERS[1:5])) # success
one.or.more(literal("A")) (LETTERS[2:5]) # failure

exactly(2,literal("A")) (c("A", LETTERS[1:5])) # success
exactly(2,literal("A")) (c(rep("A",2), LETTERS[1:5])) # failure: too many "A"

zero.or.one(literal("A")) (LETTERS[2:5]) # success
zero.or.one(literal("A")) (LETTERS[1:5]) # success
zero.or.one(literal("A")) (c("A",LETTERS[1:5])) # failure

match.n(2,literal("A")) (c("A", LETTERS[1:5])) # success
match.n(2,literal("A")) (c(rep("A",2), LETTERS[1:5])) # success

}
